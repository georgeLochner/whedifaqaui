# Coding Agent Protocol

## Environment

All commands run inside Docker containers via `docker compose exec <service> <command>`.

**Start services with this command:**

```bash
# Start services (code volume-mapped, hot reload enabled)
docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d

# Verify running
curl -s http://localhost:8000/api/health | grep -q '"status":"ok"' && echo "Backend OK"
curl -s http://localhost:9200/_cluster/health | grep -q '"status"' && echo "OpenSearch OK"

# Run commands in containers
docker compose exec backend pytest tests/unit/test_video.py -v
docker compose exec backend alembic upgrade head
docker compose exec frontend npm test

# Stop services
docker compose down
```

Services: backend(:8000), frontend(:3000), postgres(:5432), opensearch(:9200), redis(:6379)

**Shared Image:** Backend and worker share a single Docker image (`whedifaqaui-backend:phase1-deps`) built from `docker/Dockerfile.backend`. Both services use this image and differ only by their startup command. There is no separate worker Dockerfile.

**Key Principle:** Edit code on host filesystem (not inside containers). Changes reflect immediately in running containers. No rebuild needed.

**Adding Dependencies:** When you add a package to `package.json` or `requirements.txt`, install it inside the running container — do NOT rebuild the image:

```bash
# Backend: after editing requirements.txt
docker compose exec backend pip install -r requirements.txt

# Frontend: after editing package.json
docker compose exec frontend npm install
```

Only use `docker compose build` for Dockerfile changes (base image, system packages, build steps).

---

## Task Start

1. Follow the instructions in your prompt (read feature/task descriptions, check completed tasks)
2. If current task has notes from previous agent: check `git status`, `git log`, review their progress
3. Run `bd update <task-id> --status=in_progress`

---

## During Work

- Commit incrementally after each logical unit of progress
- Reference task-id in commit messages

---

## Verification Loop

Before closing any task, you MUST verify your implementation works:

1. **Run the tests specified in the task description**
   ```bash
   docker compose exec backend pytest path/to/test.py -v
   ```

2. **If tests fail:**
   - Read the failure output carefully
   - Fix the issue in your code
   - Run the tests again
   - Repeat until all tests pass

3. **If no tests are specified, verify manually:**
   - For API endpoints: `curl` or use the API
   - For frontend components: check browser at localhost:3000
   - For models/migrations: verify with `alembic upgrade head`

4. **Only close the task when:**
   - All specified tests pass
   - No regressions in related tests
   - Code is committed

**Do NOT close a task with failing tests.** The tests are your signal that the implementation is correct.

---

## Task Complete

Before closing, ask yourself: **Did I take any shortcuts I know are suboptimal?**
(Missing error handling, hardcoded values, skipped validation, incomplete tests, TODO comments, etc.)

If yes: Either fix them now, or create a follow-up task to track the technical debt.

Only close when fully done (code works, tests pass, no untracked shortcuts).
Close the task and commit code + beads together in a single commit:
```bash
bd close <task-id>
git add <code files> .beads/
git commit -m "Implement <description> (<task-id>)"
```

---

## Rules

- Only work on your assigned task - do not start additional tasks
- Exit after completing (or handing off) your assigned task
- Never close incomplete tasks
- Never close tasks with failing tests
- Never redo work previous agents committed
- Never change Docker image versions (specified in "Docker Image Versions" section in docs/design/technology-stack.md)
- If you find yourself reading more than 10 files, the task may be too large — commit progress and exit
